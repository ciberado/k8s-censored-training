# Traefik Ingress Controller

## Introduction

* Traefik is a reverse proxy (edge router) that intercepts and routes every incoming request based on rules.
* Dynamic, creates the routes for you based on autodiscovery.
* Fast, written in Go.
* Open-Source.
* Production proven.
* Circuit breakers, retries.
* Observavility can be easily configured for tracing and metrics.
* Can run everywhere, literally, as it's shipped as a docker image.
* We have a cool gopher logo as well.
* Check the official [Traefik](https://github.com/traefik/traefik/tree/master) documentation for more.

## Getting started

* Traefik can be configured with dynamic or static configuration, in our use case we will be going for static to make the lab less complex.
* Traefik can be installed using helm charts.


## Traefik Dataflow Diagram

![Traefik Architecture](https://doc.traefik.io/traefik/assets/img/architecture-overview.png)

## Preparation

* Create the `namespace` and set it as the preferred one

```bash
kubectl create ns demo-$USER
kubectl config set-context --namespace demo-$USER --current
```

* Install the resources required to run `traefik` using `helm`

```bash
helm repo add traefik https://helm.traefik.io/traefik
helm repo update

kubectl create ns traefik-$USER
helm install traefik traefik/traefik -n traefik-$USER
```

* Check the new `CRD` are available

```bash
kubectl api-resources | grep traefik
```

## Understanding Traefik port configuration

* Examine the configuration of the `deployment`. Start looking for the container arguments section to see how the different `traefik endpoints` (`traefik`, `web`, `websecure`) are defined

```bash
kubectl get deployment traefik -n traefik-$USER -ojsonpath='{.spec.template.spec.containers[0].args}' | jq
```

* Now see how those `traefik endpoints` are published with `named ports` by the `pod`

```
kubectl get deployment traefik -n traefik-$USER -ojsonpath='{.spec.template.spec.containers[0].ports}' | jq
```

* Focus on the `service` and see how two of those `named ports` are published by it (`web` and `websecure`)

```bash
kubectl get service traefik -n traefik-$USER -ojsonpath='{.spec.ports}'  | jq
```

## Accessing the Traefik endpoint

The third `traefik endpoint`  (named `traefik`) is not published by the public load balancer generated by the `service`, so we will need to create a tunnel between our laptop and the `pod` crated by the `deployment`

* Get the name of the `traefik` `pod`

```bash
TRAEFIK_POD=$(kubectl get pods --selector "app.kubernetes.io/name=traefik" -n traefik-$USER --output=name)
echo Traefik pod: $TRAEFIK_POD
```

* Choose a random port number for stablishing the tunnel

```bash
PORT=$(( ( RANDOM % 100 )  + 8000 ))
echo Port number is $PORT.
```

* Create a tunnel between your laptop and the `traefik` dashboard service

```bash
kubectl port-forward -n traefik-$USER $TRAEFIK_POD --address 0.0.0.0 $PORT:9000 &
PID=$!
echo The tunnel PID is $PID and the endpoint address is http://localhost:$PORT
```

* Open the dashboard using your local machine port

```bash
echo Open http://$(curl ifconfig.me -s):$PORT/dashboard/
```

* Click on the `HTTP routers` link to see the list of registered `IngressRules`, and look for the `ping` one

* Open the address corresponding to that rule to see it's backend

```bash
echo Open http://$(curl ifconfig.me -s):$PORT/ping
```

## Configuring the Web endpoint

* Get the host name of the public load balancer created by `traefik`


```bash
ALB_HOSTNAME=$(kubectl get svc traefik -n traefik-$USER -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
echo The public address of the load balancer is $ALB_HOSTNAME.
```

* Check how there is no backend behind the `web endpoint` load balancer

```bash
echo Open http://$ALB_HOSTNAME/
```

* Deploy a `deployment` and its `service` in your own `namespace`

```yaml
cat << EOF > pokemon-service.yaml
apiVersion: v1
kind: Service
metadata:
  name: pokemon-service
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: pokemon
  type: ClusterIP
EOF

kubectl apply -f pokemon-service.yaml

cat << EOF > pokemon.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pokemon
spec:
  replicas: 2
  selector:
    matchLabels:
      app: pokemon
  template:
    metadata:
      labels:
        app: pokemon
    spec:
      containers:
      - image: ciberado/pokemon-nodejs:0.0.1
        name: web
EOF

kubectl apply -f pokemon.yaml
```

* Define the `IngressRoute` necessary to link the `web endpoint` to the application `service`

```yaml
cat <<EOF > pokemon-ingressroute.yaml
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: pokemon-ingressroute
spec:
  entryPoints:
  - web
  routes:
  - kind: Rule
    match: Host(\`$ALB_HOSTNAME\`) && PathPrefix(\`/\`)
    services:
    - name: pokemon-service
      port: 80
      namespace: demo-$USER
EOF
```

* Apply the new route

```bash
kubectl apply -f pokemon-ingressroute.yaml
```

* Access your application trought the `web endpoint` load balancer

```bash
echo Open http://$ALB_HOSTNAME/
```

## Configuring a middleware

* Deploy another version of the `pokemon` application

```yaml
cat << EOF > pokemon-service-v2.yaml
apiVersion: v1
kind: Service
metadata:
  name: pokemon-service-v2
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
  selector:
    app: pokemon-v2
  type: ClusterIP
EOF

kubectl apply -f pokemon-service-v2.yaml

cat << EOF > pokemon-v2.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pokemon-v2
spec:
  replicas: 2
  selector:
    matchLabels:
      app: pokemon-v2
  template:
    metadata:
      labels:
        app: pokemon-v2
    spec:
      containers:
      - image: ciberado/pokemon-nodejs:0.0.2
        name: web
EOF

kubectl apply -f pokemon-v2.yaml
```

* Define a `middleware` to strip the prefix `/v2` from the path of the backend request

```yaml
cat << EOF > traefik-middleware-strip-prefix-v2.yaml
apiVersion: traefik.containo.us/v1alpha1
kind: Middleware
metadata:
  name: strip-prefix-v2
spec:
  stripPrefix:
    prefixes:
      - /v2
EOF
```

* Create the resource

```bash
kubectl apply -f traefik-middleware-strip-prefix-v2.yaml
```

* Define the new `ingressroute` for the version two of the application

```yaml
cat << EOF > pokemon-v2-ingressroute.yaml
apiVersion: traefik.containo.us/v1alpha1
kind: IngressRoute
metadata:
  name: pokemon-v2-ingressroute
spec:
  entryPoints:
  - web
  routes:
  - kind: Rule
    match: Host(\`$ALB_HOSTNAME\`) && PathPrefix(\`/v2\`)
    services:
        - name: pokemon-service-v2
          port: 80
          namespace: demo-$USER
    middlewares:
        - name: strip-prefix-v2
EOF
```

* Create the `IngressRoute`

```bash
kubectl apply -f pokemon-v2-ingressroute.yaml
```

* Access your application trought the `web endpoint` load balancer

```bash
echo Open http://$ALB_HOSTNAME/v2
```

## Clean up

* Stop the tunnel

```bash
kill -9 $PID
```

* Delete the current `namespace`

```bash
kubectl delete ns demo-$USER
```

* Uninstall the chart

```
helm delete traefik -n traefik-$USER
```

* Delete the `traefik ns`

```bash
kubectl delete ns traefik-$USER
```
